// BFS approach
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) 
    {
        /*
        We can apply bfs/dfs on the graph nodes which are unvisited and infected at time t=0 (nodes in initial vector)
        to find out the final no. of nodes infected with malware. This will give us 
        M(initial). We clearly know the infected nodes after this. But this infected no. can change
        when we remove exactly one node from the initial set of nodes. Understand that here we are not removing any nodes
        completely from the graph. We are just removing the node from initial vector which contains the nodes effected at 
        time t = 0. We will remove each node from initial vector and apply bfs on the graph. If size of initial = n
        and size of graph is N then time complexity = O(n*N*N) since we apply BFS n times and each time BFS takes N*N time 
        since its adjacency matrix
        */
        int n = initial.size();
        int ans = -1; // value of node if removed will minimize m initial
        int minimum_infected_nodes_count = INT_MAX;

        // sorting initial vector so that minimum we can iterate on the node with smallest index first
        sort(initial.begin(),initial.end());
        int current_node;
        int infected_nodes_count;
        int nodes = graph.size();
        vector<bool> infected(nodes,false);
        vector<bool> visited(nodes,false);
        queue<int> q;
        for(int i=0;i<n;i++)
        {
            // current node is removed from the initial set of infected nodes
            current_node = initial[i]; // we will calculate M(initial) if current node is removed from the initial vector
            // start BFS from all other nodes which are infected at time t=0 except from the removed node
            for(int j=0;j<nodes;j++)
            visited[j]=false;

            for(int j=0;j<n;j++)
            {
                if(initial[j]==current_node)
                continue;
                else
                {
                    q.push(initial[j]);
                    visited[initial[j]]=true; 
                }
            }
            infected_nodes_count = 0;
            while(!q.empty())
            {
                int temp = q.front();
                infected_nodes_count++;
                q.pop();
                for(int j=0;j<nodes;j++)
                {
                    if(j!=temp and graph[temp][j]==1 and visited[j]==false)
                    {
                        // there is an edge between node temp and node j
                        q.push(j);
                        visited[j]=true;
                    }
                }
            }
            if(infected_nodes_count < minimum_infected_nodes_count)
            {
                ans = current_node;
                minimum_infected_nodes_count = infected_nodes_count;
            }
        }
        return ans;
    }
};

// DSU approach
/*
LOGIC : Divide the graph into different connected components using DSU data structure. We also need a size array to find the size of a set(component). In run over the infected nodes , check to which component it belongs 
and see no. of uninfected nodes in that connected component after the removal of the infected node. If there are more than 1 infected nodes in a single connected component , then there is no way we can save any of the 
uninfected nodes by removing only 1 node.
*/
int par[301];
int set_size[301]; // used to find the size of the set
int find(int a)
{
    // find parent of a set
    if(par[a]<0)
    return a;
    else
    return find(par[a]);
}
void merge(int par_a, int par_b)
{
    // merge the smaller set into the larger set
    if(set_size[par_a] > set_size[par_b])
    {
        par[par_b]= par_a;
        set_size[par_a] += set_size[par_b];
    }
    else
    {
        par[par_a] = par_b;
        set_size[par_b] += set_size[par_a];
    }
}

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) 
    {
        int n = graph.size();
        for(int i=0;i<n;i++)
        {
            par[i]=-1;
            set_size[i]=1;
        }

        for(int i=0;i<graph.size();i++)
        {
            for(int j=0;j<graph[i].size();j++)
            {
                if(graph[i][j] == 1 and i!=j)
                {
                    int k = find(i);
                    int l = find(j);
                    if(k!=l)
                    {
                        merge(k,l);
                    }

                }
            }
        }

        /* we will form a map to find count of infected nodes in a parent */
        unordered_map<int,int> infected_mp;
        for(int i=0;i<initial.size();i++)
        {
            int parent = find(initial[i]);
            infected_mp[parent]++;
        }
        
        /*
        we will now find the no. of infected nodes present in the connected component of the infected node
        after removal each initial infected node
        */
        int ans=INT_MAX; // node if removed will leave the graph with most uninfected nodes
        int max_uninfected_nodes=-1;
        for(int i=0;i<initial.size();i++)
        {
            int parent = find(initial[i]);
            int uninfected_nodes = 0; 
            if(infected_mp[parent]>=2)
            {
                uninfected_nodes = 0; 
                // no nodes in the connected component remain uninfected after removal of current infected node
            }
            else
            {
                uninfected_nodes = set_size[parent];
            }
            if(max_uninfected_nodes <= uninfected_nodes)
            {
                if(max_uninfected_nodes == uninfected_nodes)
                ans = min(ans,initial[i]);
                else
                ans = initial[i];
                max_uninfected_nodes = uninfected_nodes;
            }
            cout<<uninfected_nodes<<endl;
        }
        return ans;
    }
};
