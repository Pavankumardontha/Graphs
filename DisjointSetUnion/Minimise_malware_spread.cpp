/*
LOGIC : Divide the graph into different connected components using DSU data structure. We also need a size array to find the size of a set(component). In run over the infected nodes , check to which component it belongs 
and see no. of uninfected nodes in that connected component after the removal of the infected node. If there are more than 1 infected nodes in a single connected component , then there is no way we can save any of the 
uninfected nodes by removing only 1 node.
*/
int par[301];
int set_size[301]; // used to find the size of the set
int find(int a)
{
    // find parent of a set
    if(par[a]<0)
    return a;
    else
    return find(par[a]);
}
void merge(int par_a, int par_b)
{
    // merge the smaller set into the larger set
    if(set_size[par_a] > set_size[par_b])
    {
        par[par_b]= par_a;
        set_size[par_a] += set_size[par_b];
    }
    else
    {
        par[par_a] = par_b;
        set_size[par_b] += set_size[par_a];
    }
}

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) 
    {
        int n = graph.size();
        for(int i=0;i<n;i++)
        {
            par[i]=-1;
            set_size[i]=1;
        }

        for(int i=0;i<graph.size();i++)
        {
            for(int j=0;j<graph[i].size();j++)
            {
                if(graph[i][j] == 1 and i!=j)
                {
                    int k = find(i);
                    int l = find(j);
                    if(k!=l)
                    {
                        merge(k,l);
                    }

                }
            }
        }

        /* we will form a map to find count of infected nodes in a parent */
        unordered_map<int,int> infected_mp;
        for(int i=0;i<initial.size();i++)
        {
            int parent = find(initial[i]);
            infected_mp[parent]++;
        }
        
        /*
        we will now find the no. of infected nodes present in the connected component of the infected node
        after removal each initial infected node
        */
        int ans=-1; // node if removed will leave the graph with most uninfected nodes
        int max_uninfected_nodes=-1;
        for(int i=0;i<initial.size();i++)
        {
            int parent = find(initial[i]);
            int uninfected_nodes = 0; 
            if(infected_mp[parent]>=2)
            {
                uninfected_nodes = 0; 
                // no nodes in the connected component remain uninfected after removal of current infected node
            }
            else
            {
                uninfected_nodes = set_size[parent]-1;
            }
            if(max_uninfected_nodes < uninfected_nodes)
            {
                ans = initial[i];
                max_uninfected_nodes = uninfected_nodes;
            }
        }
        return ans;
    }
};
