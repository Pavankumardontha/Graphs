# Standard Algorithms
1) DFS
2) BFS
3) Articulation points and bridges (notice the difference)
4) Topological Sort
5) Dijkstra 
6) Floyd warshall
7) Bellmanford 
8) Krushkal minimum spanning tree
9) Kosaraju strongly connected components

# BFS 
1) Rotten oranges (leetcode)
1) Longest path in a Tree (diameter of a tree - SPOJ)
2) Get watched videos by your friends (leetcode)
3) Word ladder - 1 (leetcode)
4) Word ladder - 2 (leetcode)
5) Jump game - 2 (leetcode)
5) Jump Game - 3 (leetcode)
6) Jump Game - 4 (leetcode)
7) Pacific Atlantic water flow (leetcode - using BFS)
8) Pacific Atlantic water flow (leetcode - using DFS very very important)
9) Most Stones Removed with Same Row or Column
10) longest cycle in a graph (can be done using both DFS and BFS)

# DFS
1) No. of islands (leetcode)
2) Flood fill (leetcode)
3) Check if path exists between source and destination node (leetcode)
4) No. of paths between source and destination nodes (+ backtracking)
5) Shortest/Largest path between source and destion node (+ backtracking)
6) Count connected components in a graph
7) Bipartite graph check ( leetcode )
8) Keys and rooms (leetcode)
9) Number of Provinces (leetcode)
10) Pacific Atlantic water flow (leetcode - using DFS)
11) All Paths From Source to Target (leetcode)
12) Longest increasing path in a matrix (leetcode)
13) Longest Path With Different Adjacent Characters (leetcode)

# DisJointSetUnion (Minimum spanning tree)
1) Minimize malware spread (leetcode -  can be done using both BFS and DSU)
2) Minimum score of a path between cities
3) Redundant connection
4) Redundant connection - II
5) Power Grid maintenance
6) Properties graph
7) Minimum Time for K Connected Components
8) Path Existence Queries in a Graph I
9) Checking Existence of Edge Length Limited Paths (leetcode)
10) Number of operations to make network connected (leetcode)
11) Remove Max Number of Edges to Keep Graph Fully Traversable (leetcode)
12) Satisfiablity of equality equations (leetcode)
13) Lexicographically smallest equivalent string (leetcode)

# TopologicalSort
1) course schedule 
2) course schedule-2
3) Alien dictionary (gfg)
4) Find eventual safe states
5) Minimum height trees

# Bridges and Articulation points
1) Submerging islands (SPOJ)



# Dijkstra 
1) Path with maximum probability
2) Network delay time
4) No. of ways to arrive destination

# Problem Set
1) Non-directed graph cycle detection
2) Directed graph cycle detection

# 2D Problem Set 
1) DFS on 2D grid 
2) BFS on 2D grid 
3) Counting connected rooms cses problem(counting connected components) ----> DFS problem 
4) Largest Area of 1's in 2D grid ------------> DFS problem
5) Jungle run(Shortest path between 2 grid points) ---> BFS problem 
6) Minimum Knight Moves(GFG) ---------> BFS problem 
7) Rotten Oranges(Important model) ----------> BFS problem
8) Swim In Rising Water ---------> Dijshiktra 
9) Path with minimum effort------>Dijshiktra
10) Number of Increasing Paths in a Grid (very very important)

Note the difference between the above 2 and understand where DFS is used and where BFS is used. Understand where to use Priority queue(Dijshiktra) and where to use simple queue(BFS) for a problem. This is very very important !!!
